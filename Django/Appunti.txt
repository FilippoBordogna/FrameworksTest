LEGENDA
- <nome> = primo_progetto
- <nome-app> = polls

## https://docs.djangoproject.com/it/3.2/intro/tutorial01/ ##

(CONTROLLO FUNZIONAMENTO DJANGO)
- COMANDO: python -m django --version

(CREARE PROGETTO)
- COMANDO: django-admin startproject <nome>

(ESECUZIONE DEL SERVER)
- Accedere alla cartella del progetto creato (<nome> di cui sopra)
- COMANDO: python manage.py runserver

(CAMBIARE IP E PORTA DEL SERVER)
- COMANDO: python manage.py runserver <porta>
- COMANDO: python manage.py runserver <ip>:<porta>

(CREARE APP)
- Accedere alla cartella dove è contenuto il file "manage.py"
- COMANDO: python manage.py startapp <nome-app>

(CREARE UNA VISTA)
- Nel file <nome-app>/views.py CODICE:
    from django.http import HttpResponse

    def index(request):
        return HttpResponse("Hello, world. You're at the polls index.")
    
(CONFIGURARE GLI INDIRIZZI (URL) NELLA CARTELLA DELL'APP)
- Crea nella cartella un file col nome "urls.py"
- Nel file "<nome-app>/urls.py" CODICE:
    from django.urls import path

    from . import views

    urlpatterns = [
        path('', views.index, name='index'),
    ]

(PUNTARE LA CONFIGURAZIONE DEGLI INDIRIZZI PRINCIPALI A QUELLI DELL'APP)
- CODICE:
    from django.contrib import admin
    from django.urls import include, path

    urlpatterns = [
        path('polls/', include('polls.urls')), #<-
        path('admin/', admin.site.urls),
    ]

## https://docs.djangoproject.com/it/3.2/intro/tutorial02/ ##

(MODIFICA DEL MODELLO DEL DB)
3 passaggi per apportare modifiche al modello:
- Modifica i tuoi modelli (in models.py).
- COMANDO: python manage.py makemigrations per creare le migrazioni per queste modifiche
- COMANDO: python manage.py migrate <migrate> per applicare le modifiche al database

(ACCESSO ALLA SHELL)
- COMANDO: py manage.py shell

(CREARE UN UTENTE ADMIN)
- COMANDO: py manage.py createsuperuser

(CREARE UN INTERFACCIA ADMIN)
Nel File "polls/admin.py" CODICE:
	from django.contrib import admin

	from .models import Question

	admin.site.register(Question)

## https://docs.djangoproject.com/it/3.2/intro/tutorial03/ ##

(VISTA PIU' ELABORATA)
- CODICE:
    from django.http import HttpResponse
    # from django.template import loader
    from django.shortcuts import get_object_or_404, render
    from django.http import Http404

    from .models import Question

    ## VISTA SEMPLICE ##
    def index(request): # RESTITUISCO LE ULTIME 5 DOMANDE IN ORDINE CRONOLOGICO
        latest_question_list = Question.objects.order_by('-pub_date')[:5]
        #template = loader.get_template('polls/index.html') # Richiamo il template al percorso 'template/polls/index.html'
        context = {'latest_question_list': latest_question_list} # Preparo il contesto da passare
        # return HttpResponse(template.render(context, request)) # Ritorno una risposta mediante template a cui passo il contento e la richiesta
        return render(request, 'polls/index.html', context) # Ritorno una risposta mediante caricamento (render) di un template a cui passo il contento e la richiesta

    ## VISTE CON PARAMETRI ##

    def detail(request, question_id):
        '''
        try:
            question = Question.objects.get(pk=question_id)
        except Question.DoesNotExist: # Non esiste la domanda con id = question_id
            raise Http404("La domanda non esiste") 
        '''
        question = get_object_or_404(Question, pk=question_id) # (modello, get_args_array): Se l'oggetto non esiste Errore 404
        return render(request, 'polls/detail.html', {'question': question})

    def results(request, question_id):
        response = "You're looking at the results of question %s."
        return HttpResponse(response % question_id)
        
- Ogni view è responsabile di fare una delle due cose:
    - restituire un oggetto HttpResponse con il contenuto della pagina richiesta
    - sollevare una eccezione come Http404

(NAMESPACE DELLE URL)
- Nel file <nome-app>/urls.py inserisci un app_name per impostare il namespace della applicazione per evitare conflitti o errori.
- CODICE:
    app_name = 'polls' # Specifico il namespace in modo che altre app non creino conflitto
    urlpatterns = [
        # ex: /polls/
        path('', views.index, name='index'),
        ...

(DESIGN/STILE DELL'APP)
- Crea una directory chiamata templates nella tua directory <nome-app>. Django cercherà i templates lì dentro.
- Dobbiamo far puntare Django al template giusto, ed il miglior modo di assicurarcene è facendone il namespacing ovvero mettendo questi template in una  sottodirectory chiamata come l’applicazione stessa (ex. template/<nome-app>)
- CODICE file 'template/<nome-app>/<nome-metodo-views>:
    {% if latest_question_list %} <!-- Controllo la presenza di elementi nella lista -->
        <ul> <!-- Creo una lista -->
        {% for question in latest_question_list %} <!-- Ciclo fra le domande -->
            <!-- <li><a href="/polls/{{ question.id }}/">{{ question.question_text }}</a></li> -->
            <li><a href="{% url 'polls:detail' question.id %}">{{ question.question_text }}</a></li> <!-- Elemento della lista contenente il Link contenuto nella vista detail -->
        {% endfor %}
        </ul>
    {% else %}
        <p>No polls are available.</p> <!-- Comunico la mancanza di elementi -->
    {% endif %}

- uso {{}} per "stampare" il valore di una variabile 
    
(CONTROLLI SUI PARAMETRI PASSATI)
- Per non fare TRY-CATCH si usa il CODICE: get_<object/list>_or_404(modello, argomenti) che acquisisce con get/filter l'oggetto <modello>: se non esiste lancia errore 404

## https://docs.djangoproject.com/it/3.2/intro/tutorial04/ ##

(FORM)
- CODICE:
   <form action="{% url 'polls:vote' question.id %}" method="post"> <!-- Form che permette di votare -->
    {% csrf_token %}
    <fieldset>
        <legend><h1>{{ question.question_text }}</h1></legend>
        {% if error_message %}<p><strong>{{ error_message }}</strong></p>{% endif %} <!-- Caso d'errore -->
        {% for choice in question.choice_set.all %}
            <input type="radio" name="choice" id="choice{{ forloop.counter }}" value="{{ choice.id }}"> <!-- Possibili risposte alla domanda -->
            <label for="choice{{ forloop.counter }}">{{ choice.choice_text }}</label><br> <!-- forloop.counter = contatore del for -->
        {% endfor %}
    </fieldset>
    <input type="submit" value="Vote"> <!-- Conferma del voto -->
    </form>
    
(VISTA CHE GESTISCE UNA POST DA UNA FORM)
- CODICE:
    question = get_object_or_404(Question, pk=question_id) # Prendo la domanda con pk = question_id. Se non esiste Errore 404
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice']) # Prendo l'oggetto scelta corrispondente alla risposta
    except (KeyError, Choice.DoesNotExist): # Non esiste una scelta con pk = valore_form
        # Rimostro la form contenente domanda e risposte tra cui scegliere (chiamata polls/detail).
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1 # Incremento i voti
        selected_choice.save() # Salvo
        # Ritorno un HttpResponseRedirect dopo il successo di una post per prevenire il riPost conseguente al tasto indietro
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
    
- Dopo il successo di una chiamata POST dovuta ad una form redirigere ad un'altra pagina per non effettuare il RiPost in caso di click sul tasto indietro
- CODICE:
    return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))
    
(ACCESSO CONCORRENTE AL DB)
- GUARDA: https://docs.djangoproject.com/it/3.2/ref/models/expressions/#avoiding-race-conditions-using-f

(GESTIONE DEL PLURALE IN INGLESE)
- CODICE: 
    {{ choice.votes|pluralize }}
    
(CONVERSIONE DA VISTA A VISTA GENERICA)
- converti la configurazione delle URL.
- Cancella alcune delle vecchie, non necessarie viste.
- Introduci nuove visualizzazioni basate sulle generic views di Django.
- CODICE:
  file "<nome-app>/urls":
    app_name = 'polls' # Specifico il namespace in modo che altre app non creino conflitto
    urlpatterns = [
    path('', views.IndexView.as_view(), name='index'), # ListView
    path('<int:pk>/', views.DetailView.as_view(), name='detail'), # DetailView: necessita del parametro pk
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'), # DetailView: necessita del parametro pk 
    path('<int:question_id>/vote/', views.vote, name='vote'), # NormalView
    ]
    
  file "<nome-app>/views"
    # VISTE GENERICHE

    # ListView usa un template di default chiamato <app name>/<model name>_list.html
    # Nel nostro caso, dovrebbe usare il template "polls/question_list"
    # La variabile di contesto generata automaticamente è question_list
    class IndexView(generic.ListView): # Modello ListView
        template_name = 'polls/index.html' # template specifico invece del nome di template generato automaticamente
        context_object_name = 'latest_question_list' # Sovrascrivo la variabile di contesto generata automaticamente

        def get_queryset(self):
            """Return the last five published questions."""
            return Question.objects.order_by('-pub_date')[:5]

    # DetailView usa un template chiamato <app name>/<model name>_detail.html. 
    # Nel nostro caso, dovrebbe usare il template "polls/question_detail.html"
    # La variabile di contesto generata automaticamente è question
    class DetailView(generic.DetailView): #Modello DetailView: Si aspetta che la chiave primaria che viene passata dalla URL si chiami "pk"
        model = Question 
        template_name = 'polls/detail.html' # template specifico invece del nome di template generato automaticamente


    class ResultsView(generic.DetailView):
        model = Question
        template_name = 'polls/results.html' # template specifico invece del nome di template generato automaticamente

    # VISTE CLASSICHE

    def vote(request, question_id):
        question = get_object_or_404(Question, pk=question_id) # Prendo la domanda con pk = question_id. Se non esiste Errore 404
        try:
            selected_choice = question.choice_set.get(pk=request.POST['choice']) # Prendo l'oggetto scelta corrispondente alla risposta
        except (KeyError, Choice.DoesNotExist): # Non esiste una scelta con pk = valore_form
            # Rimostro la form contenente domanda e risposte tra cui scegliere (chiamata polls/detail).
            return render(request, 'polls/detail.html', {
                'question': question,
                'error_message': "You didn't select a choice.",
            })
        else:
            selected_choice.votes += 1 # Incremento i voti
            selected_choice.save() # Salvo
            # Ritorno un HttpResponseRedirect dopo il successo di una post per prevenire il riPost conseguente al tasto indietro
            return HttpResponseRedirect(reverse('polls:results', args=(question.id,))) # reverse(nome-view) ; args=argomenti che richiede la view
            
- ListView 
    - Usa un template di default chiamato <app name>/<model name>_list.html
    - La variabile di contesto generata automaticamente è question_list
- DetailView 
    - Usa un template chiamato <app name>/<model name>_detail.html. 
    - La variabile di contesto generata automaticamente è question
- Usare template specifico invece del nome di template generato automaticamente
    template_name = '<nome-template>' 
- Sovrascrivere la variabile di contesto generata automaticamente
    context_object_name = '<nome-variabile>'
    
## https://docs.djangoproject.com/it/3.2/intro/tutorial05/ ##

(CREARE UN TEST)
- Nel file <mia-app>/tests.py CODICE:
    class QuestionModelTests(TestCase):

        def test_was_published_recently_with_future_question(self):
            '''
            was_published_recently() 
            dovrebbe ritornare False per domande la cui pub_date è nel futuro.
            '''
            
            time = timezone.now() + datetime.timedelta(days=30) # Timezone futuro (fra 30 giorni)
            future_question = Question(pub_date=time) # Creo la domanda (nel futuro)
            self.assertIs(future_question.was_published_recently(), False) # Testo la funzione was_published_recently() che dovrebbe restituire False
        
        [...]

    # NOTA: La funzione è fuori dalla classe        
    def create_question(question_text, days):
        """
        Crea una domanda con testo uguale a quello del parametro question_text
        e pubblicato con scostamento pari al valore del parametro days (<0 -> pubblicato nel passato ; >0 -> pubblicato nel futuro)
        """
        time = timezone.now() + datetime.timedelta(days=days) # Creo il timezione partendo da quello di oggi e scostando per il numero di giorni
        return Question.objects.create(question_text=question_text, pub_date=time) # Creo la domanda
      
    class QuestionIndexViewTests(TestCase):
        def test_no_questions(self):
            """
            Se non esistono domande dovrei mostrare un messaggio appropriato
            """
            
            response = self.client.get(reverse('polls:index')) # Prendo la risposta alla chiamata alla view index
            self.assertEqual(response.status_code, 200) # Il codice di risposta dovrebbe essere 200 (TUTTO OK)
            self.assertContains(response, "No polls are available.") # La risposta dovrebbe essere "No polls are available"
            self.assertQuerysetEqual(response.context['latest_question_list'], []) # La lista delle ultime domande dovrebbe essere vuota

        [...]

                   
    class QuestionDetailViewTests(TestCase):
        def test_future_question(self):
            """
            La chiamata alla vista dettaglio di una domanda con pub_date nel futuro
            dovrebbe restituire un codice 404 Not Found
            """
            
            future_question = create_question(question_text='Future question.', days=5) # Creo una domanda con data di pubblicazione futura
            url = reverse('polls:detail', args=(future_question.id,)) # Preparo l'URL della chiamata alla vista view della domanda (futura)
            response = self.client.get(url) # Prendo la risposta alla chiamata alla view detail di cui ho preparato l'URL sopra
            self.assertEqual(response.status_code, 404) # Lo stato della risposta dovrebbe essere 404

        def test_past_question(self):
            """
            La chiamata alla vista dettaglio di una domanda con pub_date nel passato
            dovrebbe mostrare il testo della domanda
            """
            past_question = create_question(question_text='Past Question.', days=-5) # Creo una domanda con data di pubblicazione passata
            url = reverse('polls:detail', args=(past_question.id,)) # Preparo l'URL della chiamata alla vista view della domanda (passata)
            response = self.client.get(url) # Prendo la risposta alla chiamata alla view detail di cui ho preparato l'URL sopra
            self.assertContains(response, past_question.question_text) # La risposta dovrebbe contenere il testo della domanda  
        
- Eseguire il test COMANDO: py manage.py test polls

(MODIFICA DELLE VISTE PER TEST)
- CODICE:
    class IndexView(generic.ListView): # Modello ListView
        template_name = 'polls/index.html' # template specifico invece del nome di template generato automaticamente
        context_object_name = 'latest_question_list' # Sovrascrivo la variabile di contesto generata automaticamente

        def get_queryset(self): # Restituisce le ultime 5 domande NON tenendo conto di quelle schedulate in futuro
            return Question.objects.filter(pub_date__lte=timezone.now()).order_by('-pub_date')[:5]
    
## https://docs.djangoproject.com/it/3.2/intro/tutorial06/ ##

(FOGLI DI STILE)
- Crea il foglio di stile all'indirizzo '<nome-app>/static/<nome-app>/style.css')
- Laddove necessario per includere i file statici: 
    CODICE:
        {% load static %} <!-- Generazione dell'URL assoluto dei file statici -->
        <link rel="stylesheet" type="text/css" href="{% static 'polls/style.css' %}"> <!-- Inclusione del file css -->
        
(AGGIUNTA DI UN IMMAGINE DI SFONDO)
- Salva un immagine all'indirizzo '<mia-app>/static/<mia-app>/images/background.gif'
- Nel foglio di stile all'indirizzo <nome-app>/static/<nome-app>/style.css inserisci 
    CODICE:
        body {
            background: white url("images/background.gif") no-repeat;
        }

## https://docs.djangoproject.com/it/3.2/intro/tutorial07/ ##

(PERSONALIZZARE IL MODULO DI AMMINISTRAZIONE)
- Nel file <mia-app>/admin.py:
    - Per modificare l'ordine dei campi 
      CODICE:
        class QuestionAdmin(admin.ModelAdmin):
            fields = ['pub_date', 'question_text']

        admin.site.register(Question, QuestionAdmin)

    - Per dividere i moduli in gruppi
      CODICE:
        class QuestionAdmin(admin.ModelAdmin):
            fieldsets = [
                (None,               {'fields': ['question_text']}), # Area 1: Testo della domanda (il primo campo è il titolo)
                ('Date information', {'fields': ['pub_date']}), # Area 2: Data di pubblicazione
            ] # Dichiaro l'ordine di visualizzazione dei campi quando modifico/aggiungo una domanda

        admin.site.register(Question, QuestionAdmin)
        
    - Aggiunta di oggetti correlati
      CODICE:
        class ChoiceInline(admin.StackedInline): # Visualizzazione tabulare
            model = Choice # Modello
            extra = 3 # Numero di 'slot' di default (puoi aggiungerne e toglierne dall'interfaccia grafica)

        class QuestionAdmin(admin.ModelAdmin):
            fieldsets = [
                    (None,               {'fields': ['question_text']}), # Area 1: Testo della domanda (il primo campo è il titolo)
                    ('Date information', {'fields': ['pub_date']}), # Area 2: Data di pubblicazione
                ] # Dichiaro l'ordine di visualizzazione dei campi quando modifico/aggiungo una domanda
            inlines = [ChoiceInline] # Aggiungo il modulo ChoiceInline dichiarato sopra
            
    - Passare a visione tabulare dichiarare la classe così
      CODICE:
        class ChoiceInline(admin.StackedInline):

    - Per personalizzare l’interfaccia di amministrazione con lista di parametri e ordine, filtri e ricerche:
      CODICE:
        list_display = ('question_text', 'pub_date', 'was_published_recently') # Dichiaro l'ordine di visualizzazione dei campi nella pagina delle domande
        list_filter = ['pub_date'] # Aggiungo un filtro per data di pubblicazione (tendina a destra)
        search_fields = ['question_text'] # Aggiungo una casella di ricerca in base al testo della domanda
        
- Modificare la visualizzazione di una funzione:
  Nel file <mia-app>/models.py:
  CODICE:
    class Question(models.Model):
        [...]
        @admin.display(
            boolean=True,
            ordering='pub_date',
            description='Published recently?',
        ) # Dichiaro la visualizzazione della funzione was_published_recently
        
        def was_published_recently(self):
            '''
            Restituisce True se la domanda è stata pubblicata meno di un giorno fa ; False altrimenti
            '''
            now = timezone.now()
            return now - datetime.timedelta(days=1) <= self.pub_date <= now # Controllo che la data di pubblicazione sia nelle precedenti 24h e NON nel futuro

- Personalizzare i template dell'amministrazione (e del progetto in generale):
    - Crea la directory <nome>/templates
    - Nel file mysite/settings.py aggiungi un’opzione DIRS nell’impostazione TEMPLATES:
      CODICE:
        TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [BASE_DIR / 'templates'], # Indirizzo del template
            [...]
        }]
    
    - Crea la directory <nome>/templates/admin e copia al suo interno il modello C:\Python39\Lib\site-packages\django\contrib\admin\templates\admin\base_site.html
      (Per conoscere il percorso contenente i template standard usare il COMANDO: py -c "import django; print(django.__path__)")
    - Modifica il file copiato (<nome>/templates/admin/base_site.html) così:
      CODICE:
        [...]
        {% block branding %}
        <h1 id="site-name"><a href="{% url 'admin:index' %}">Amministrazione dei sondaggi</a></h1> <!-- Titolo -->
        {% endblock %}
        [...]